<?xml version="1.0" encoding="UTF-8"?><testsuites failures="43" name="dependency-check" tests="34"><testsuite failures="6" id="0" name="/home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar" package="arc-1.13.7.Final.jar" skipped="2" tests="8" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29427" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.2 (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle from version 5.1 and before version 7.0 there is a vulnerability which can lead to information disclosure and/or dependency poisoning. Repository content filtering is a security control Gradle introduced to help users specify what repositories are used to resolve specific dependencies. This feature was introduced in the wake of the &quot;A Confusing Dependency&quot; blog post. In some cases, Gradle may ignore content filters and search all repositories for dependencies. This only occurs when repository content filtering is used from within a `pluginManagement` block in a settings file. This may change how dependencies are resolved for Gradle plugins and build scripts. For builds that are vulnerable, there are two risks: 1) Information disclosure: Gradle could make dependency requests to repositories outside your organization and leak internal package identifiers. 2) Dependency poisoning/Dependency confusion: Gradle could download a malicious binary from a repository outside your organization due to name squatting. For a full example and more details refer to the referenced GitHub Security Advisory. The problem has been patched and released with Gradle 7.0. Users relying on this feature should upgrade their build as soon as possible. As a workaround, users may use a company repository which has the right rules for fetching packages from public repositories, or use project level repository content filtering, inside `buildscript.repositories`. This option is available since Gradle 5.1 when the feature was introduced.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29428" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.8 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle before version 7.0, on Unix-like systems, the system temporary directory can be created with open permissions that allow multiple users to create and delete files within it. Gradle builds could be vulnerable to a local privilege escalation from an attacker quickly deleting and recreating files in the system temporary directory. This vulnerability impacted builds using precompiled script plugins written in Kotlin DSL and tests for Gradle plugins written using ProjectBuilder or TestKit. If you are on Windows or modern versions of macOS, you are not vulnerable. If you are on a Unix-like operating system with the &quot;sticky&quot; bit set on your system temporary directory, you are not vulnerable. The problem has been patched and released with Gradle 7.0. As a workaround, on Unix-like operating systems, ensure that the &quot;sticky&quot; bit is set. This only allows the original user (or root) to delete a file. If you are unable to change the permissions of the system temporary directory, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only. For additional details refer to the referenced GitHub Security Advisory.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29429" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.5 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>In Gradle before version 7.0, files created with open permissions in the system temporary directory can allow an attacker to access information downloaded by Gradle. Some builds could be vulnerable to a local information disclosure. Remote files accessed through TextResourceFactory are downloaded into the system temporary directory first. Sensitive information contained in these files can be exposed to other local users on the same system. If you do not use the `TextResourceFactory` API, you are not vulnerable. As of Gradle 7.0, uses of the system temporary directory have been moved to the Gradle User Home directory. By default, this directory is restricted to the user running the build. As a workaround, set a more restrictive umask that removes read access to other users. When files are created in the system temporary directory, they will not be accessible to other users. If you are unable to change your system&apos;s umask, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-3642" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>A flaw was found in Wildfly Elytron in versions prior to 1.10.14.Final, prior to 1.15.5.Final and prior to 1.16.1.Final where ScramServer may be susceptible to Timing Attack if enabled. The highest threat of this vulnerability is confidentiality.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-37714" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)"/><system-out>jsoup is a Java library for working with HTML. Those using jsoup versions prior to 1.14.2 to parse untrusted HTML or XML may be vulnerable to DOS attacks. If the parser is run on user supplied input, an attacker may supply content that causes the parser to get stuck (loop indefinitely until cancelled), to complete more slowly than usual, or to throw an unexpected exception. This effect may support a denial of service attack. The issue is patched in version 1.14.2. There are a few available workarounds. Users may rate limit input parsing, limit the size of inputs based on system resources, and/or implement thread watchdogs to cap and timeout parse runtimes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus.arc/arc@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/arc/arc/1.13.7.Final/arc-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="1" name="/home/jenkins/.mvnrepository/org/graalvm/sdk/graal-sdk/21.0.0/graal-sdk-21.0.0.jar" package="graal-sdk-21.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="graal-sdk-21.0.0.jar"/></testsuite><testsuite failures="0" id="2" name="/home/jenkins/.mvnrepository/jakarta/annotation/jakarta.annotation-api/1.3.5/jakarta.annotation-api-1.3.5.jar" package="jakarta.annotation-api-1.3.5.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jakarta.annotation-api-1.3.5.jar"/></testsuite><testsuite failures="1" id="3" name="/home/jenkins/.mvnrepository/jakarta/el/jakarta.el-api/3.0.3/jakarta.el-api-3.0.3.jar" package="jakarta.el-api-3.0.3.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/jakarta.el/jakarta.el-api@3.0.3"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/jakarta/el/jakarta.el-api/3.0.3/jakarta.el-api-3.0.3.jar</system-err></testcase></testsuite><testsuite failures="0" id="4" name="/home/jenkins/.mvnrepository/jakarta/enterprise/jakarta.enterprise.cdi-api/2.0.2/jakarta.enterprise.cdi-api-2.0.2.jar" package="jakarta.enterprise.cdi-api-2.0.2.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jakarta.enterprise.cdi-api-2.0.2.jar"/></testsuite><testsuite failures="0" id="5" name="/home/jenkins/.mvnrepository/jakarta/inject/jakarta.inject-api/1.0/jakarta.inject-api-1.0.jar" package="jakarta.inject-api-1.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jakarta.inject-api-1.0.jar"/></testsuite><testsuite failures="0" id="6" name="/home/jenkins/.mvnrepository/jakarta/interceptor/jakarta.interceptor-api/1.2.5/jakarta.interceptor-api-1.2.5.jar" package="jakarta.interceptor-api-1.2.5.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jakarta.interceptor-api-1.2.5.jar"/></testsuite><testsuite failures="0" id="7" name="/home/jenkins/.mvnrepository/jakarta/transaction/jakarta.transaction-api/1.3.3/jakarta.transaction-api-1.3.3.jar" package="jakarta.transaction-api-1.3.3.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jakarta.transaction-api-1.3.3.jar"/></testsuite><testsuite failures="0" id="8" name="/home/jenkins/.mvnrepository/org/jboss/logging/jboss-logging/3.4.1.Final/jboss-logging-3.4.1.Final.jar" package="jboss-logging-3.4.1.Final.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jboss-logging-3.4.1.Final.jar"/></testsuite><testsuite failures="0" id="9" name="/home/jenkins/.mvnrepository/org/jboss/logging/jboss-logging-annotations/2.2.0.Final/jboss-logging-annotations-2.2.0.Final.jar" package="jboss-logging-annotations-2.2.0.Final.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jboss-logging-annotations-2.2.0.Final.jar"/></testsuite><testsuite failures="0" id="10" name="/home/jenkins/.mvnrepository/org/jboss/logmanager/jboss-logmanager-embedded/1.0.9/jboss-logmanager-embedded-1.0.9.jar" package="jboss-logmanager-embedded-1.0.9.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jboss-logmanager-embedded-1.0.9.jar"/></testsuite><testsuite failures="0" id="11" name="/home/jenkins/.mvnrepository/org/jboss/threads/jboss-threads/3.2.0.Final/jboss-threads-3.2.0.Final.jar" package="jboss-threads-3.2.0.Final.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="jboss-threads-3.2.0.Final.jar"/></testsuite><testsuite failures="0" id="12" name="/home/jenkins/.mvnrepository/org/eclipse/microprofile/config/microprofile-config-api/1.4/microprofile-config-api-1.4.jar" package="microprofile-config-api-1.4.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="microprofile-config-api-1.4.jar"/></testsuite><testsuite failures="0" id="13" name="/home/jenkins/.mvnrepository/org/eclipse/microprofile/context-propagation/microprofile-context-propagation-api/1.0.1/microprofile-context-propagation-api-1.0.1.jar" package="microprofile-context-propagation-api-1.0.1.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="microprofile-context-propagation-api-1.0.1.jar"/></testsuite><testsuite failures="0" id="14" name="/home/jenkins/.mvnrepository/mysql/mysql-connector-java/8.0.21/mysql-connector-java-8.0.21.jar" package="mysql-connector-java-8.0.21.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="mysql-connector-java-8.0.21.jar"/></testsuite><testsuite failures="0" id="15" name="/home/jenkins/.mvnrepository/com/oracle/ojdbc/ojdbc8/19.3.0.0/ojdbc8-19.3.0.0.jar" package="ojdbc8-19.3.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="ojdbc8-19.3.0.0.jar"/></testsuite><testsuite failures="0" id="16" name="/home/jenkins/.mvnrepository/com/oracle/ojdbc/ons/19.3.0.0/ons-19.3.0.0.jar" package="ons-19.3.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="ons-19.3.0.0.jar"/></testsuite><testsuite failures="0" id="17" name="/home/jenkins/.mvnrepository/com/oracle/ojdbc/oraclepki/19.3.0.0/oraclepki-19.3.0.0.jar" package="oraclepki-19.3.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="oraclepki-19.3.0.0.jar"/></testsuite><testsuite failures="0" id="18" name="/home/jenkins/.mvnrepository/com/oracle/ojdbc/osdt_cert/19.3.0.0/osdt_cert-19.3.0.0.jar" package="osdt_cert-19.3.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="osdt_cert-19.3.0.0.jar"/></testsuite><testsuite failures="0" id="19" name="/home/jenkins/.mvnrepository/com/oracle/ojdbc/osdt_core/19.3.0.0/osdt_core-19.3.0.0.jar" package="osdt_core-19.3.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="osdt_core-19.3.0.0.jar"/></testsuite><testsuite failures="0" id="20" name="/home/jenkins/.mvnrepository/info/picocli/picocli/4.6.1/picocli-4.6.1.jar" package="picocli-4.6.1.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="picocli-4.6.1.jar"/></testsuite><testsuite failures="0" id="21" name="/home/jenkins/.mvnrepository/org/postgresql/postgresql/42.2.14/postgresql-42.2.14.jar" package="postgresql-42.2.14.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="postgresql-42.2.14.jar"/></testsuite><testsuite failures="0" id="22" name="/home/jenkins/.mvnrepository/com/google/protobuf/protobuf-java/3.14.0/protobuf-java-3.14.0.jar" package="protobuf-java-3.14.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="protobuf-java-3.14.0.jar"/></testsuite><testsuite failures="6" id="23" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar" package="quarkus-arc-1.13.7.Final.jar" skipped="2" tests="8" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29427" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.2 (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle from version 5.1 and before version 7.0 there is a vulnerability which can lead to information disclosure and/or dependency poisoning. Repository content filtering is a security control Gradle introduced to help users specify what repositories are used to resolve specific dependencies. This feature was introduced in the wake of the &quot;A Confusing Dependency&quot; blog post. In some cases, Gradle may ignore content filters and search all repositories for dependencies. This only occurs when repository content filtering is used from within a `pluginManagement` block in a settings file. This may change how dependencies are resolved for Gradle plugins and build scripts. For builds that are vulnerable, there are two risks: 1) Information disclosure: Gradle could make dependency requests to repositories outside your organization and leak internal package identifiers. 2) Dependency poisoning/Dependency confusion: Gradle could download a malicious binary from a repository outside your organization due to name squatting. For a full example and more details refer to the referenced GitHub Security Advisory. The problem has been patched and released with Gradle 7.0. Users relying on this feature should upgrade their build as soon as possible. As a workaround, users may use a company repository which has the right rules for fetching packages from public repositories, or use project level repository content filtering, inside `buildscript.repositories`. This option is available since Gradle 5.1 when the feature was introduced.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29428" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.8 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle before version 7.0, on Unix-like systems, the system temporary directory can be created with open permissions that allow multiple users to create and delete files within it. Gradle builds could be vulnerable to a local privilege escalation from an attacker quickly deleting and recreating files in the system temporary directory. This vulnerability impacted builds using precompiled script plugins written in Kotlin DSL and tests for Gradle plugins written using ProjectBuilder or TestKit. If you are on Windows or modern versions of macOS, you are not vulnerable. If you are on a Unix-like operating system with the &quot;sticky&quot; bit set on your system temporary directory, you are not vulnerable. The problem has been patched and released with Gradle 7.0. As a workaround, on Unix-like operating systems, ensure that the &quot;sticky&quot; bit is set. This only allows the original user (or root) to delete a file. If you are unable to change the permissions of the system temporary directory, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only. For additional details refer to the referenced GitHub Security Advisory.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29429" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.5 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>In Gradle before version 7.0, files created with open permissions in the system temporary directory can allow an attacker to access information downloaded by Gradle. Some builds could be vulnerable to a local information disclosure. Remote files accessed through TextResourceFactory are downloaded into the system temporary directory first. Sensitive information contained in these files can be exposed to other local users on the same system. If you do not use the `TextResourceFactory` API, you are not vulnerable. As of Gradle 7.0, uses of the system temporary directory have been moved to the Gradle User Home directory. By default, this directory is restricted to the user running the build. As a workaround, set a more restrictive umask that removes read access to other users. When files are created in the system temporary directory, they will not be accessible to other users. If you are unable to change your system&apos;s umask, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-3642" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>A flaw was found in Wildfly Elytron in versions prior to 1.10.14.Final, prior to 1.15.5.Final and prior to 1.16.1.Final where ScramServer may be susceptible to Timing Attack if enabled. The highest threat of this vulnerability is confidentiality.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-37714" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)"/><system-out>jsoup is a Java library for working with HTML. Those using jsoup versions prior to 1.14.2 to parse untrusted HTML or XML may be vulnerable to DOS attacks. If the parser is run on user supplied input, an attacker may supply content that causes the parser to get stuck (loop indefinitely until cancelled), to complete more slowly than usual, or to throw an unexpected exception. This effect may support a denial of service attack. The issue is patched in version 1.14.2. There are a few available workarounds. Users may rate limit input parsing, limit the size of inputs based on system resources, and/or implement thread watchdogs to cap and timeout parse runtimes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-arc@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-arc/1.13.7.Final/quarkus-arc-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="6" id="24" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar" package="quarkus-bootstrap-runner-1.13.7.Final.jar" skipped="2" tests="8" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29427" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.2 (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle from version 5.1 and before version 7.0 there is a vulnerability which can lead to information disclosure and/or dependency poisoning. Repository content filtering is a security control Gradle introduced to help users specify what repositories are used to resolve specific dependencies. This feature was introduced in the wake of the &quot;A Confusing Dependency&quot; blog post. In some cases, Gradle may ignore content filters and search all repositories for dependencies. This only occurs when repository content filtering is used from within a `pluginManagement` block in a settings file. This may change how dependencies are resolved for Gradle plugins and build scripts. For builds that are vulnerable, there are two risks: 1) Information disclosure: Gradle could make dependency requests to repositories outside your organization and leak internal package identifiers. 2) Dependency poisoning/Dependency confusion: Gradle could download a malicious binary from a repository outside your organization due to name squatting. For a full example and more details refer to the referenced GitHub Security Advisory. The problem has been patched and released with Gradle 7.0. Users relying on this feature should upgrade their build as soon as possible. As a workaround, users may use a company repository which has the right rules for fetching packages from public repositories, or use project level repository content filtering, inside `buildscript.repositories`. This option is available since Gradle 5.1 when the feature was introduced.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29428" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.8 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle before version 7.0, on Unix-like systems, the system temporary directory can be created with open permissions that allow multiple users to create and delete files within it. Gradle builds could be vulnerable to a local privilege escalation from an attacker quickly deleting and recreating files in the system temporary directory. This vulnerability impacted builds using precompiled script plugins written in Kotlin DSL and tests for Gradle plugins written using ProjectBuilder or TestKit. If you are on Windows or modern versions of macOS, you are not vulnerable. If you are on a Unix-like operating system with the &quot;sticky&quot; bit set on your system temporary directory, you are not vulnerable. The problem has been patched and released with Gradle 7.0. As a workaround, on Unix-like operating systems, ensure that the &quot;sticky&quot; bit is set. This only allows the original user (or root) to delete a file. If you are unable to change the permissions of the system temporary directory, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only. For additional details refer to the referenced GitHub Security Advisory.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29429" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.5 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>In Gradle before version 7.0, files created with open permissions in the system temporary directory can allow an attacker to access information downloaded by Gradle. Some builds could be vulnerable to a local information disclosure. Remote files accessed through TextResourceFactory are downloaded into the system temporary directory first. Sensitive information contained in these files can be exposed to other local users on the same system. If you do not use the `TextResourceFactory` API, you are not vulnerable. As of Gradle 7.0, uses of the system temporary directory have been moved to the Gradle User Home directory. By default, this directory is restricted to the user running the build. As a workaround, set a more restrictive umask that removes read access to other users. When files are created in the system temporary directory, they will not be accessible to other users. If you are unable to change your system&apos;s umask, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-3642" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>A flaw was found in Wildfly Elytron in versions prior to 1.10.14.Final, prior to 1.15.5.Final and prior to 1.16.1.Final where ScramServer may be susceptible to Timing Attack if enabled. The highest threat of this vulnerability is confidentiality.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-37714" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)"/><system-out>jsoup is a Java library for working with HTML. Those using jsoup versions prior to 1.14.2 to parse untrusted HTML or XML may be vulnerable to DOS attacks. If the parser is run on user supplied input, an attacker may supply content that causes the parser to get stuck (loop indefinitely until cancelled), to complete more slowly than usual, or to throw an unexpected exception. This effect may support a denial of service attack. The issue is patched in version 1.14.2. There are a few available workarounds. Users may rate limit input parsing, limit the size of inputs based on system resources, and/or implement thread watchdogs to cap and timeout parse runtimes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-bootstrap-runner@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-bootstrap-runner/1.13.7.Final/quarkus-bootstrap-runner-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="6" id="25" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar" package="quarkus-core-1.13.7.Final.jar" skipped="2" tests="8" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29427" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.2 (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle from version 5.1 and before version 7.0 there is a vulnerability which can lead to information disclosure and/or dependency poisoning. Repository content filtering is a security control Gradle introduced to help users specify what repositories are used to resolve specific dependencies. This feature was introduced in the wake of the &quot;A Confusing Dependency&quot; blog post. In some cases, Gradle may ignore content filters and search all repositories for dependencies. This only occurs when repository content filtering is used from within a `pluginManagement` block in a settings file. This may change how dependencies are resolved for Gradle plugins and build scripts. For builds that are vulnerable, there are two risks: 1) Information disclosure: Gradle could make dependency requests to repositories outside your organization and leak internal package identifiers. 2) Dependency poisoning/Dependency confusion: Gradle could download a malicious binary from a repository outside your organization due to name squatting. For a full example and more details refer to the referenced GitHub Security Advisory. The problem has been patched and released with Gradle 7.0. Users relying on this feature should upgrade their build as soon as possible. As a workaround, users may use a company repository which has the right rules for fetching packages from public repositories, or use project level repository content filtering, inside `buildscript.repositories`. This option is available since Gradle 5.1 when the feature was introduced.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29428" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.8 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle before version 7.0, on Unix-like systems, the system temporary directory can be created with open permissions that allow multiple users to create and delete files within it. Gradle builds could be vulnerable to a local privilege escalation from an attacker quickly deleting and recreating files in the system temporary directory. This vulnerability impacted builds using precompiled script plugins written in Kotlin DSL and tests for Gradle plugins written using ProjectBuilder or TestKit. If you are on Windows or modern versions of macOS, you are not vulnerable. If you are on a Unix-like operating system with the &quot;sticky&quot; bit set on your system temporary directory, you are not vulnerable. The problem has been patched and released with Gradle 7.0. As a workaround, on Unix-like operating systems, ensure that the &quot;sticky&quot; bit is set. This only allows the original user (or root) to delete a file. If you are unable to change the permissions of the system temporary directory, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only. For additional details refer to the referenced GitHub Security Advisory.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29429" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.5 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>In Gradle before version 7.0, files created with open permissions in the system temporary directory can allow an attacker to access information downloaded by Gradle. Some builds could be vulnerable to a local information disclosure. Remote files accessed through TextResourceFactory are downloaded into the system temporary directory first. Sensitive information contained in these files can be exposed to other local users on the same system. If you do not use the `TextResourceFactory` API, you are not vulnerable. As of Gradle 7.0, uses of the system temporary directory have been moved to the Gradle User Home directory. By default, this directory is restricted to the user running the build. As a workaround, set a more restrictive umask that removes read access to other users. When files are created in the system temporary directory, they will not be accessible to other users. If you are unable to change your system&apos;s umask, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-3642" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>A flaw was found in Wildfly Elytron in versions prior to 1.10.14.Final, prior to 1.15.5.Final and prior to 1.16.1.Final where ScramServer may be susceptible to Timing Attack if enabled. The highest threat of this vulnerability is confidentiality.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-37714" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)"/><system-out>jsoup is a Java library for working with HTML. Those using jsoup versions prior to 1.14.2 to parse untrusted HTML or XML may be vulnerable to DOS attacks. If the parser is run on user supplied input, an attacker may supply content that causes the parser to get stuck (loop indefinitely until cancelled), to complete more slowly than usual, or to throw an unexpected exception. This effect may support a denial of service attack. The issue is patched in version 1.14.2. There are a few available workarounds. Users may rate limit input parsing, limit the size of inputs based on system resources, and/or implement thread watchdogs to cap and timeout parse runtimes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-core@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-core/1.13.7.Final/quarkus-core-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="6" id="26" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar" package="quarkus-development-mode-spi-1.13.7.Final.jar" skipped="2" tests="8" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29427" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.2 (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle from version 5.1 and before version 7.0 there is a vulnerability which can lead to information disclosure and/or dependency poisoning. Repository content filtering is a security control Gradle introduced to help users specify what repositories are used to resolve specific dependencies. This feature was introduced in the wake of the &quot;A Confusing Dependency&quot; blog post. In some cases, Gradle may ignore content filters and search all repositories for dependencies. This only occurs when repository content filtering is used from within a `pluginManagement` block in a settings file. This may change how dependencies are resolved for Gradle plugins and build scripts. For builds that are vulnerable, there are two risks: 1) Information disclosure: Gradle could make dependency requests to repositories outside your organization and leak internal package identifiers. 2) Dependency poisoning/Dependency confusion: Gradle could download a malicious binary from a repository outside your organization due to name squatting. For a full example and more details refer to the referenced GitHub Security Advisory. The problem has been patched and released with Gradle 7.0. Users relying on this feature should upgrade their build as soon as possible. As a workaround, users may use a company repository which has the right rules for fetching packages from public repositories, or use project level repository content filtering, inside `buildscript.repositories`. This option is available since Gradle 5.1 when the feature was introduced.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29428" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.8 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle before version 7.0, on Unix-like systems, the system temporary directory can be created with open permissions that allow multiple users to create and delete files within it. Gradle builds could be vulnerable to a local privilege escalation from an attacker quickly deleting and recreating files in the system temporary directory. This vulnerability impacted builds using precompiled script plugins written in Kotlin DSL and tests for Gradle plugins written using ProjectBuilder or TestKit. If you are on Windows or modern versions of macOS, you are not vulnerable. If you are on a Unix-like operating system with the &quot;sticky&quot; bit set on your system temporary directory, you are not vulnerable. The problem has been patched and released with Gradle 7.0. As a workaround, on Unix-like operating systems, ensure that the &quot;sticky&quot; bit is set. This only allows the original user (or root) to delete a file. If you are unable to change the permissions of the system temporary directory, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only. For additional details refer to the referenced GitHub Security Advisory.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29429" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.5 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>In Gradle before version 7.0, files created with open permissions in the system temporary directory can allow an attacker to access information downloaded by Gradle. Some builds could be vulnerable to a local information disclosure. Remote files accessed through TextResourceFactory are downloaded into the system temporary directory first. Sensitive information contained in these files can be exposed to other local users on the same system. If you do not use the `TextResourceFactory` API, you are not vulnerable. As of Gradle 7.0, uses of the system temporary directory have been moved to the Gradle User Home directory. By default, this directory is restricted to the user running the build. As a workaround, set a more restrictive umask that removes read access to other users. When files are created in the system temporary directory, they will not be accessible to other users. If you are unable to change your system&apos;s umask, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-3642" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>A flaw was found in Wildfly Elytron in versions prior to 1.10.14.Final, prior to 1.15.5.Final and prior to 1.16.1.Final where ScramServer may be susceptible to Timing Attack if enabled. The highest threat of this vulnerability is confidentiality.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-37714" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)"/><system-out>jsoup is a Java library for working with HTML. Those using jsoup versions prior to 1.14.2 to parse untrusted HTML or XML may be vulnerable to DOS attacks. If the parser is run on user supplied input, an attacker may supply content that causes the parser to get stuck (loop indefinitely until cancelled), to complete more slowly than usual, or to throw an unexpected exception. This effect may support a denial of service attack. The issue is patched in version 1.14.2. There are a few available workarounds. Users may rate limit input parsing, limit the size of inputs based on system resources, and/or implement thread watchdogs to cap and timeout parse runtimes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-development-mode-spi@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-development-mode-spi/1.13.7.Final/quarkus-development-mode-spi-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="6" id="27" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar" package="quarkus-ide-launcher-1.13.7.Final.jar" skipped="2" tests="8" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29427" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.2 (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle from version 5.1 and before version 7.0 there is a vulnerability which can lead to information disclosure and/or dependency poisoning. Repository content filtering is a security control Gradle introduced to help users specify what repositories are used to resolve specific dependencies. This feature was introduced in the wake of the &quot;A Confusing Dependency&quot; blog post. In some cases, Gradle may ignore content filters and search all repositories for dependencies. This only occurs when repository content filtering is used from within a `pluginManagement` block in a settings file. This may change how dependencies are resolved for Gradle plugins and build scripts. For builds that are vulnerable, there are two risks: 1) Information disclosure: Gradle could make dependency requests to repositories outside your organization and leak internal package identifiers. 2) Dependency poisoning/Dependency confusion: Gradle could download a malicious binary from a repository outside your organization due to name squatting. For a full example and more details refer to the referenced GitHub Security Advisory. The problem has been patched and released with Gradle 7.0. Users relying on this feature should upgrade their build as soon as possible. As a workaround, users may use a company repository which has the right rules for fetching packages from public repositories, or use project level repository content filtering, inside `buildscript.repositories`. This option is available since Gradle 5.1 when the feature was introduced.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29428" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.8 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle before version 7.0, on Unix-like systems, the system temporary directory can be created with open permissions that allow multiple users to create and delete files within it. Gradle builds could be vulnerable to a local privilege escalation from an attacker quickly deleting and recreating files in the system temporary directory. This vulnerability impacted builds using precompiled script plugins written in Kotlin DSL and tests for Gradle plugins written using ProjectBuilder or TestKit. If you are on Windows or modern versions of macOS, you are not vulnerable. If you are on a Unix-like operating system with the &quot;sticky&quot; bit set on your system temporary directory, you are not vulnerable. The problem has been patched and released with Gradle 7.0. As a workaround, on Unix-like operating systems, ensure that the &quot;sticky&quot; bit is set. This only allows the original user (or root) to delete a file. If you are unable to change the permissions of the system temporary directory, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only. For additional details refer to the referenced GitHub Security Advisory.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29429" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.5 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>In Gradle before version 7.0, files created with open permissions in the system temporary directory can allow an attacker to access information downloaded by Gradle. Some builds could be vulnerable to a local information disclosure. Remote files accessed through TextResourceFactory are downloaded into the system temporary directory first. Sensitive information contained in these files can be exposed to other local users on the same system. If you do not use the `TextResourceFactory` API, you are not vulnerable. As of Gradle 7.0, uses of the system temporary directory have been moved to the Gradle User Home directory. By default, this directory is restricted to the user running the build. As a workaround, set a more restrictive umask that removes read access to other users. When files are created in the system temporary directory, they will not be accessible to other users. If you are unable to change your system&apos;s umask, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-3642" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>A flaw was found in Wildfly Elytron in versions prior to 1.10.14.Final, prior to 1.15.5.Final and prior to 1.16.1.Final where ScramServer may be susceptible to Timing Attack if enabled. The highest threat of this vulnerability is confidentiality.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-37714" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)"/><system-out>jsoup is a Java library for working with HTML. Those using jsoup versions prior to 1.14.2 to parse untrusted HTML or XML may be vulnerable to DOS attacks. If the parser is run on user supplied input, an attacker may supply content that causes the parser to get stuck (loop indefinitely until cancelled), to complete more slowly than usual, or to throw an unexpected exception. This effect may support a denial of service attack. The issue is patched in version 1.14.2. There are a few available workarounds. Users may rate limit input parsing, limit the size of inputs based on system resources, and/or implement thread watchdogs to cap and timeout parse runtimes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-ide-launcher@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-ide-launcher/1.13.7.Final/quarkus-ide-launcher-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="6" id="28" name="/home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar" package="quarkus-picocli-1.13.7.Final.jar" skipped="2" tests="8" timestamp="2021-11-22T17:18:35.24239"><testcase classname="CVE-2021-28170" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N)"/><system-out>In the Jakarta Expression Language implementation 3.0.3 and earlier, a bug in the ELParserTokenManager enables invalid EL expressions to be evaluated as if they were valid.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29427" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.2 (CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle from version 5.1 and before version 7.0 there is a vulnerability which can lead to information disclosure and/or dependency poisoning. Repository content filtering is a security control Gradle introduced to help users specify what repositories are used to resolve specific dependencies. This feature was introduced in the wake of the &quot;A Confusing Dependency&quot; blog post. In some cases, Gradle may ignore content filters and search all repositories for dependencies. This only occurs when repository content filtering is used from within a `pluginManagement` block in a settings file. This may change how dependencies are resolved for Gradle plugins and build scripts. For builds that are vulnerable, there are two risks: 1) Information disclosure: Gradle could make dependency requests to repositories outside your organization and leak internal package identifiers. 2) Dependency poisoning/Dependency confusion: Gradle could download a malicious binary from a repository outside your organization due to name squatting. For a full example and more details refer to the referenced GitHub Security Advisory. The problem has been patched and released with Gradle 7.0. Users relying on this feature should upgrade their build as soon as possible. As a workaround, users may use a company repository which has the right rules for fetching packages from public repositories, or use project level repository content filtering, inside `buildscript.repositories`. This option is available since Gradle 5.1 when the feature was introduced.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29428" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.8 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H)"/><system-out>In Gradle before version 7.0, on Unix-like systems, the system temporary directory can be created with open permissions that allow multiple users to create and delete files within it. Gradle builds could be vulnerable to a local privilege escalation from an attacker quickly deleting and recreating files in the system temporary directory. This vulnerability impacted builds using precompiled script plugins written in Kotlin DSL and tests for Gradle plugins written using ProjectBuilder or TestKit. If you are on Windows or modern versions of macOS, you are not vulnerable. If you are on a Unix-like operating system with the &quot;sticky&quot; bit set on your system temporary directory, you are not vulnerable. The problem has been patched and released with Gradle 7.0. As a workaround, on Unix-like operating systems, ensure that the &quot;sticky&quot; bit is set. This only allows the original user (or root) to delete a file. If you are unable to change the permissions of the system temporary directory, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only. For additional details refer to the referenced GitHub Security Advisory.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-29429" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.5 (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>In Gradle before version 7.0, files created with open permissions in the system temporary directory can allow an attacker to access information downloaded by Gradle. Some builds could be vulnerable to a local information disclosure. Remote files accessed through TextResourceFactory are downloaded into the system temporary directory first. Sensitive information contained in these files can be exposed to other local users on the same system. If you do not use the `TextResourceFactory` API, you are not vulnerable. As of Gradle 7.0, uses of the system temporary directory have been moved to the Gradle User Home directory. By default, this directory is restricted to the user running the build. As a workaround, set a more restrictive umask that removes read access to other users. When files are created in the system temporary directory, they will not be accessible to other users. If you are unable to change your system&apos;s umask, you can move the Java temporary directory by setting the System Property `java.io.tmpdir`. The new path needs to limit permissions to the build user only.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-3642" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><failure message="cvssV3: MEDIUM, score: 5.3 (CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N)"/><system-out>A flaw was found in Wildfly Elytron in versions prior to 1.10.14.Final, prior to 1.15.5.Final and prior to 1.16.1.Final where ScramServer may be susceptible to Timing Attack if enabled. The highest threat of this vulnerability is confidentiality.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-37714" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><failure message="cvssV3: HIGH, score: 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)"/><system-out>jsoup is a Java library for working with HTML. Those using jsoup versions prior to 1.14.2 to parse untrusted HTML or XML may be vulnerable to DOS attacks. If the parser is run on user supplied input, an attacker may supply content that causes the parser to get stuck (loop indefinitely until cancelled), to complete more slowly than usual, or to throw an unexpected exception. This effect may support a denial of service attack. The issue is patched in version 1.14.2. There are a few available workarounds. Users may rate limit input parsing, limit the size of inputs based on system resources, and/or implement thread watchdogs to cap and timeout parse runtimes.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21295" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel&apos;s pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase><testcase classname="CVE-2021-21290" name="pkg:maven/io.quarkus/quarkus-picocli@1.13.7.Final"><skipped message="Not much we can do about this one except implementing Quarkus 2 which will require significant effort." /><system-out>Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. In Netty before version 4.1.59.Final there is a vulnerability on Unix-like systems involving an insecure temp file. When netty&apos;s multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. On unix-like systems, the temporary directory is shared between all user. As such, writing to this directory using APIs that do not explicitly set the file/directory permissions can lead to information disclosure. Of note, this does not impact modern MacOS Operating Systems. The method &quot;File.createTempFile&quot; on unix-like systems creates a random file, but, by default will create this file with the permissions &quot;-rw-r--r--&quot;. Thus, if sensitive information is written to this file, other local users can read this information. This is the case in netty&apos;s &quot;AbstractDiskHttpData&quot; is vulnerable. This has been fixed in version 4.1.59.Final. As a workaround, one may specify your own &quot;java.io.tmpdir&quot; when you start the JVM or use &quot;DefaultHttpDataFactory.setBaseDir(...)&quot; to set the directory to something that is only readable by the current user.</system-out><system-err>location: /home/jenkins/.mvnrepository/io/quarkus/quarkus-picocli/1.13.7.Final/quarkus-picocli-1.13.7.Final.jar</system-err></testcase></testsuite><testsuite failures="0" id="29" name="/home/jenkins/.mvnrepository/com/oracle/ojdbc/simplefan/19.3.0.0/simplefan-19.3.0.0.jar" package="simplefan-19.3.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="simplefan-19.3.0.0.jar"/></testsuite><testsuite failures="0" id="30" name="/home/jenkins/.mvnrepository/org/slf4j/slf4j-api/1.7.16/slf4j-api-1.7.16.jar" package="slf4j-api-1.7.16.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="slf4j-api-1.7.16.jar"/></testsuite><testsuite failures="0" id="31" name="/home/jenkins/.mvnrepository/org/jboss/slf4j/slf4j-jboss-logmanager/1.1.0.Final/slf4j-jboss-logmanager-1.1.0.Final.jar" package="slf4j-jboss-logmanager-1.1.0.Final.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="slf4j-jboss-logmanager-1.1.0.Final.jar"/></testsuite><testsuite failures="0" id="32" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-annotation/1.5.0/smallrye-common-annotation-1.5.0.jar" package="smallrye-common-annotation-1.5.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-common-annotation-1.5.0.jar"/></testsuite><testsuite failures="0" id="33" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-classloader/1.5.0/smallrye-common-classloader-1.5.0.jar" package="smallrye-common-classloader-1.5.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-common-classloader-1.5.0.jar"/></testsuite><testsuite failures="0" id="34" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-constraint/1.5.0/smallrye-common-constraint-1.5.0.jar" package="smallrye-common-constraint-1.5.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-common-constraint-1.5.0.jar"/></testsuite><testsuite failures="0" id="35" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-expression/1.5.0/smallrye-common-expression-1.5.0.jar" package="smallrye-common-expression-1.5.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-common-expression-1.5.0.jar"/></testsuite><testsuite failures="0" id="36" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-function/1.5.0/smallrye-common-function-1.5.0.jar" package="smallrye-common-function-1.5.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-common-function-1.5.0.jar"/></testsuite><testsuite failures="0" id="37" name="/home/jenkins/.mvnrepository/io/smallrye/common/smallrye-common-io/1.5.0/smallrye-common-io-1.5.0.jar" package="smallrye-common-io-1.5.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-common-io-1.5.0.jar"/></testsuite><testsuite failures="0" id="38" name="/home/jenkins/.mvnrepository/io/smallrye/config/smallrye-config/1.13.1/smallrye-config-1.13.1.jar" package="smallrye-config-1.13.1.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-config-1.13.1.jar"/></testsuite><testsuite failures="0" id="39" name="/home/jenkins/.mvnrepository/io/smallrye/config/smallrye-config-common/1.13.1/smallrye-config-common-1.13.1.jar" package="smallrye-config-common-1.13.1.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="smallrye-config-common-1.13.1.jar"/></testsuite><testsuite failures="0" id="40" name="/home/jenkins/.mvnrepository/com/oracle/ojdbc/ucp/19.3.0.0/ucp-19.3.0.0.jar" package="ucp-19.3.0.0.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="ucp-19.3.0.0.jar"/></testsuite><testsuite failures="0" id="41" name="/home/jenkins/.mvnrepository/org/wildfly/common/wildfly-common/1.5.4.Final-format-001/wildfly-common-1.5.4.Final-format-001.jar" package="wildfly-common-1.5.4.Final-format-001.jar" skipped="0" tests="1" timestamp="2021-11-22T17:18:35.24239"><testcase classname="dependency-check" name="wildfly-common-1.5.4.Final-format-001.jar"/></testsuite></testsuites>