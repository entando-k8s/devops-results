<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ApsEntityManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Entando Core: Engine</a> &gt; <a href="index.source.html" class="el_package">com.agiletec.aps.system.common.entity</a> &gt; <span class="el_source">ApsEntityManager.java</span></div><h1>ApsEntityManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-Present Entando Inc. (http://www.entando.com) All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */
package com.agiletec.aps.system.common.entity;

import org.entando.entando.ent.util.EntSafeXmlUtils;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;

import com.agiletec.aps.system.common.AbstractService;
import com.agiletec.aps.system.common.entity.cache.IEntityManagerCacheWrapper;
import com.agiletec.aps.system.common.entity.event.EntityTypesChangingEvent;
import com.agiletec.aps.system.common.entity.event.ReloadingEntitiesReferencesEvent;
import com.agiletec.aps.system.common.entity.event.ReloadingEntitiesReferencesObserver;
import com.agiletec.aps.system.common.entity.loader.AttributeDisablingCodesLoader;
import com.agiletec.aps.system.common.entity.loader.AttributeRolesLoader;
import com.agiletec.aps.system.common.entity.model.ApsEntityRecord;
import com.agiletec.aps.system.common.entity.model.EntitySearchFilter;
import com.agiletec.aps.system.common.entity.model.IApsEntity;
import com.agiletec.aps.system.common.entity.model.SmallEntityType;
import com.agiletec.aps.system.common.entity.model.attribute.AttributeInterface;
import com.agiletec.aps.system.common.entity.model.attribute.AttributeRole;
import com.agiletec.aps.system.common.entity.parse.EntityHandler;
import com.agiletec.aps.system.common.entity.parse.IApsEntityDOM;
import com.agiletec.aps.system.common.entity.parse.IEntityTypeDOM;
import com.agiletec.aps.system.common.entity.parse.IEntityTypeFactory;
import org.entando.entando.ent.exception.EntException;
import com.agiletec.aps.util.DateConverter;
import org.apache.commons.beanutils.BeanComparator;
import org.entando.entando.ent.util.EntLogging.EntLogger;
import org.entando.entando.ent.util.EntLogging.EntLogFactory;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/**
 * This abstract service must be extended in all those services that make use of
 * ApsEntities. By default, extending the manager, it is necessary to implement
 * the method that returns the specific category manager and, in the definition
 * of the Spring service, the configuration item where to look for the
 * definitions of the Entity Types handled by the service.
 *
 * @author E.Santoboni
 */
<span class="fc" id="L68">public abstract class ApsEntityManager extends AbstractService</span>
                                       implements IEntityManager, IEntityTypesConfigurer, ReloadingEntitiesReferencesObserver {

    /**
     * Prefix of the thread used for references reloading.
     */
    public static final String RELOAD_REFERENCES_THREAD_NAME_PREFIX = &quot;RELOAD_REFERENCES_INDEX_&quot;;

<span class="fc" id="L76">    private static final EntLogger logger = EntLogFactory.getSanitizedLogger(ApsEntityManager.class);</span>

    private IEntityTypeFactory entityTypeFactory;

    private Class entityClass;

    private String configItemName;

    private IEntityTypeDOM entityTypeDom;

    private EntityHandler entityHandler;

    private String xmlAttributeRootElementName;

    private IApsEntityDOM entityDom;

<span class="fc" id="L92">    private Map&lt;String, AttributeRole&gt; attributeRoles = null;</span>

<span class="fc" id="L94">    private Map&lt;String, String&gt; attributeDisablingCodes = null;</span>

    private String attributeRolesFileName;

    private String attributeDisablingCodesFileName;

    private IEntityManagerCacheWrapper cacheWrapper;

    @Override
    public void init() throws Exception {
<span class="fc" id="L104">        this.entityDom.setRootElementName(this.getXmlAttributeRootElementName());</span>
<span class="fc" id="L105">        this.getCacheWrapper().initCache(super.getName());</span>
<span class="fc" id="L106">        logger.debug(&quot;{} : inizializated&quot;, this.getName());</span>
<span class="fc" id="L107">    }</span>

    @Override
    public void refresh() throws Throwable {
<span class="fc" id="L111">        super.refresh();</span>
<span class="fc" id="L112">        this.attributeDisablingCodes = null;</span>
<span class="fc" id="L113">        this.attributeRoles = null;</span>
<span class="fc" id="L114">    }</span>

    @Override
    public Map&lt;String, String&gt; getAttributeDisablingCodes() {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (null != this.attributeDisablingCodes) {</span>
            //codes already loaded
<span class="fc" id="L120">            return this.attributeDisablingCodes;</span>
        }
        //codes not loaded yet
<span class="fc" id="L123">        AttributeDisablingCodesLoader loader = new AttributeDisablingCodesLoader();</span>
<span class="fc" id="L124">        this.attributeDisablingCodes = loader.extractDisablingCodes(this.getAttributeDisablingCodesFileName(), super.getBeanFactory(), this);</span>
<span class="fc" id="L125">        Map&lt;String, String&gt; clone = new HashMap&lt;&gt;();</span>
<span class="fc" id="L126">        clone.putAll(this.attributeDisablingCodes);</span>
<span class="fc" id="L127">        return clone;</span>
    }

    @Override
    public List&lt;AttributeRole&gt; getAttributeRoles() {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (null != this.attributeRoles) {</span>
            //roles already loaded
<span class="fc" id="L134">            return this.getOrderedAttributeRoles();</span>
        }
        //roles not loaded yet
<span class="fc" id="L137">        this.initAttributeRoles();</span>
<span class="fc" id="L138">        return this.getOrderedAttributeRoles();</span>
    }

    protected void initAttributeRoles() {
<span class="fc" id="L142">        this.attributeRoles = new HashMap&lt;&gt;();</span>
<span class="fc" id="L143">        AttributeRolesLoader loader = new AttributeRolesLoader();</span>
<span class="fc" id="L144">        this.attributeRoles = loader.extractAttributeRoles(this.getAttributeRolesFileName(), super.getBeanFactory(), this);</span>
<span class="fc" id="L145">    }</span>

    private List&lt;AttributeRole&gt; getOrderedAttributeRoles() {
<span class="fc" id="L148">        List&lt;AttributeRole&gt; roles = new ArrayList&lt;&gt;(this.attributeRoles.size());</span>
<span class="fc" id="L149">        Iterator&lt;AttributeRole&gt; iter = this.attributeRoles.values().iterator();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L151">            AttributeRole role = iter.next();</span>
<span class="fc" id="L152">            roles.add(role.clone());</span>
<span class="fc" id="L153">        }</span>
<span class="fc" id="L154">        BeanComparator comparator = new BeanComparator(&quot;name&quot;);</span>
<span class="fc" id="L155">        Collections.sort(roles, comparator);</span>
<span class="fc" id="L156">        return roles;</span>
    }

    @Override
    public AttributeRole getAttributeRole(String roleName) {
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (null == this.attributeRoles) {</span>
<span class="nc" id="L162">            this.initAttributeRoles();</span>
        }
<span class="nc" id="L164">        AttributeRole role = this.attributeRoles.get(roleName);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (null != role) {</span>
<span class="nc" id="L166">            return role.clone();</span>
        }
<span class="nc" id="L168">        return null;</span>
    }

    /**
     * Create and populate the entity as specified by its type and XML
     * definition.
     *
     * @param entityTypeCode The Entity Type code.
     * @param xml The XML of the associated entity.
     * @return The populated entity.
     * @throws EntException If errors detected while retrieving the
     * entity.
     */
    protected IApsEntity createEntityFromXml(String entityTypeCode, String xml) throws EntException {
        try {
<span class="fc" id="L183">            IApsEntity entityPrototype = this.getEntityPrototype(entityTypeCode);</span>
<span class="fc" id="L184">            SAXParser parser = EntSafeXmlUtils.newSafeSAXParser();</span>
<span class="fc" id="L185">            InputSource is = new InputSource(new StringReader(xml));</span>
<span class="fc" id="L186">            EntityHandler handler = this.getEntityHandler();</span>
<span class="fc" id="L187">            handler.initHandler(entityPrototype, this.getXmlAttributeRootElementName());</span>
<span class="fc" id="L188">            parser.parse(is, handler);</span>
<span class="fc" id="L189">            return entityPrototype;</span>
<span class="nc" id="L190">        } catch (ParserConfigurationException | SAXException | IOException t) {</span>
<span class="nc" id="L191">            logger.error(&quot;Error detected while creating the entity. typecode: {} - xml: {}&quot;, entityTypeCode, xml, t);</span>
<span class="nc" id="L192">            throw new EntException(&quot;Error detected while creating the entity&quot;, t);</span>
        }
    }

    /**
     * Indicates whether the service makes use of the search engine. Default
     * value: false.
     *
     * @return true if the services uses the search engine, false otherwise.
     */
    @Override
    public boolean isSearchEngineUser() {
<span class="nc" id="L204">        return false;</span>
    }

    @Override
    public IApsEntity getEntityPrototype(String typeCode) {
<span class="fc" id="L209">        IApsEntity prototype = null;</span>
        try {
<span class="fc" id="L211">            IApsEntity mainPrototype = this.getEntityTypeFactory().extractEntityType(typeCode, this.getEntityClass(),</span>
<span class="fc" id="L212">                                                                                     this.getConfigItemName(), this.getEntityTypeDom(), super.getName(), this.getEntityDom());</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">            if (null == mainPrototype) {</span>
<span class="fc" id="L214">                return null;</span>
            }
<span class="fc" id="L216">            prototype = mainPrototype.getEntityPrototype();</span>
<span class="nc" id="L217">        } catch (Exception e) {</span>
<span class="nc" id="L218">            logger.error(&quot;Error while extracting entity type {}&quot;, typeCode, e);</span>
<span class="nc" id="L219">            throw new RuntimeException(&quot;Error while extracting entity type &quot; + typeCode, e);</span>
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">        return prototype;</span>
    }

    @Override
    public Map&lt;String, IApsEntity&gt; getEntityPrototypes() {
<span class="fc" id="L226">        Map&lt;String, IApsEntity&gt; prototypes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L227">        Map&lt;String, IApsEntity&gt; mainPrototypes = this.getEntityTypes();</span>
<span class="fc" id="L228">        Iterator&lt;String&gt; iter = mainPrototypes.keySet().iterator();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L230">            String code = iter.next();</span>
<span class="fc" id="L231">            IApsEntity mainPrototype = mainPrototypes.get(code);</span>
<span class="fc" id="L232">            prototypes.put(code, mainPrototype.getEntityPrototype());</span>
<span class="fc" id="L233">        }</span>
<span class="fc" id="L234">        return prototypes;</span>
    }

    /**
     * Add a new entity prototype on the catalog.
     *
     * @param entityType The entity type to add.
     * @throws EntException In case of error.
     */
    @Override
    public void addEntityPrototype(IApsEntity entityType) throws EntException {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (null == entityType) {</span>
<span class="nc" id="L246">            throw new EntException(&quot;Invalid entity type to add&quot;);</span>
        }
<span class="fc" id="L248">        Map&lt;String, IApsEntity&gt; newEntityTypes = this.getEntityTypes();</span>
<span class="fc" id="L249">        newEntityTypes.put(entityType.getTypeCode(), entityType);</span>
<span class="fc" id="L250">        this.updateEntityPrototypes(newEntityTypes);</span>
<span class="fc" id="L251">        this.notifyEntityTypesChanging(null, entityType, EntityTypesChangingEvent.INSERT_OPERATION_CODE);</span>
<span class="fc" id="L252">    }</span>

    /**
     * Update an entity prototype on the catalog.
     *
     * @param entityType The entity type to update.
     * @throws EntException In case of error.
     */
    @Override
    public void updateEntityPrototype(IApsEntity entityType) throws EntException {
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">        if (null == entityType) {</span>
<span class="nc" id="L263">            throw new EntException(&quot;Invalid entity type to update&quot;);</span>
        }
<span class="fc" id="L265">        Map&lt;String, IApsEntity&gt; entityTypes = this.getEntityTypes();</span>
<span class="fc" id="L266">        IApsEntity oldEntityType = entityTypes.get(entityType.getTypeCode());</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (null == oldEntityType) {</span>
<span class="nc" id="L268">            throw new EntException(&quot;No entity type to update with code '&quot; + entityType.getTypeCode() + &quot;' where found&quot;);</span>
        }
<span class="fc" id="L270">        entityTypes.put(entityType.getTypeCode(), entityType);</span>
<span class="fc" id="L271">        this.updateEntityPrototypes(entityTypes);</span>
<span class="fc" id="L272">        this.verifyReloadingNeeded(oldEntityType, entityType);</span>
<span class="fc" id="L273">        this.notifyEntityTypesChanging(oldEntityType, entityType, EntityTypesChangingEvent.UPDATE_OPERATION_CODE);</span>
<span class="fc" id="L274">    }</span>

    protected void verifyReloadingNeeded(IApsEntity oldEntityType, IApsEntity newEntityType) {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        if (this.getStatus(newEntityType.getTypeCode()) == STATUS_NEED_TO_RELOAD_REFERENCES) {</span>
<span class="nc" id="L278">            return;</span>
        }
<span class="fc" id="L280">        List&lt;AttributeInterface&gt; attributes = oldEntityType.getAttributeList();</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (int i = 0; i &lt; attributes.size(); i++) {</span>
<span class="fc" id="L282">            AttributeInterface oldAttribute = attributes.get(i);</span>
<span class="fc" id="L283">            AttributeInterface newAttribute = (AttributeInterface) newEntityType.getAttribute(oldAttribute.getName());</span>
<span class="pc bpc" id="L284" title="2 of 8 branches missed.">            if ((oldAttribute.isSearchable() &amp;&amp; null == newAttribute) || (null != newAttribute &amp;&amp; oldAttribute.isSearchable() != newAttribute.isSearchable())) {</span>
<span class="nc" id="L285">                this.setStatus(IEntityManager.STATUS_NEED_TO_RELOAD_REFERENCES, oldEntityType.getTypeCode());</span>
<span class="nc" id="L286">                return;</span>
            }
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            String[] oldRoles = (null != oldAttribute.getRoles()) ? oldAttribute.getRoles() : new String[0];</span>
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">            String[] newRoles = (null != newAttribute &amp;&amp; null != newAttribute.getRoles()) ? newAttribute.getRoles() : new String[0];</span>
<span class="pc bpc" id="L290" title="2 of 4 branches missed.">            if (newRoles.length == 0 &amp;&amp; oldRoles.length == 0) {</span>
<span class="fc" id="L291">                continue;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            } else if (newRoles.length != oldRoles.length) {</span>
<span class="nc" id="L293">                this.setStatus(IEntityManager.STATUS_NEED_TO_RELOAD_REFERENCES, oldEntityType.getTypeCode());</span>
<span class="nc" id="L294">                return;</span>
            } else {
<span class="nc" id="L296">                List&lt;String&gt; oldRolesList = Arrays.asList(oldRoles);</span>
<span class="nc" id="L297">                List&lt;String&gt; newRolesList = Arrays.asList(newRoles);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                for (int j = 0; j &lt; newRolesList.size(); j++) {</span>
<span class="nc" id="L299">                    String roleName = newRolesList.get(j);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">                    if (!oldRolesList.contains(roleName)) {</span>
<span class="nc" id="L301">                        this.setStatus(IEntityManager.STATUS_NEED_TO_RELOAD_REFERENCES, oldEntityType.getTypeCode());</span>
<span class="nc" id="L302">                        return;</span>
                    }
                }
            }
        }
<span class="fc" id="L307">    }</span>

    /**
     * Remove an entity type from the catalog.
     *
     * @param entityTypeCode The code of the entity type to remove.
     * @throws EntException In case of error.
     */
    @Override
    public void removeEntityPrototype(String entityTypeCode) throws EntException {
<span class="fc" id="L317">        Map&lt;String, IApsEntity&gt; entityTypes = this.getEntityTypes();</span>
<span class="fc" id="L318">        IApsEntity entityTypeToRemove = entityTypes.get(entityTypeCode);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        if (null == entityTypeToRemove) {</span>
<span class="nc" id="L320">            throw new EntException(&quot;No entity type to remove with code '&quot; + entityTypeCode + &quot;' were found&quot;);</span>
        }
<span class="fc" id="L322">        entityTypes.remove(entityTypeCode);</span>
<span class="fc" id="L323">        this.updateEntityPrototypes(entityTypes);</span>
<span class="fc" id="L324">        this.notifyEntityTypesChanging(entityTypeToRemove, null, EntityTypesChangingEvent.REMOVE_OPERATION_CODE);</span>
<span class="fc" id="L325">    }</span>

    /**
     * Update entity prototypes
     *
     * @param newEntityTypes the map, indexed by code, containing the new
     * entities.
     * @throws EntException If errors are detected during the process.
     */
    private void updateEntityPrototypes(Map&lt;String, IApsEntity&gt; newEntityTypes) throws EntException {
        try {
<span class="fc" id="L336">            this.getEntityTypeFactory().updateEntityTypes(newEntityTypes, this.getConfigItemName(), this.getEntityTypeDom());</span>
<span class="fc" id="L337">            this.refresh();</span>
<span class="nc" id="L338">        } catch (Throwable t) {</span>
<span class="nc" id="L339">            logger.error(&quot;Error detected while updating entity prototypes&quot;, t);</span>
<span class="nc" id="L340">            throw new EntException(&quot;Error detected while updating entity prototypes&quot;, t);</span>
<span class="fc" id="L341">        }</span>
<span class="fc" id="L342">    }</span>

    private void notifyEntityTypesChanging(IApsEntity oldEntityType, IApsEntity newEntityType, int operationCode) {
<span class="fc" id="L345">        EntityTypesChangingEvent event = new EntityTypesChangingEvent();</span>
<span class="fc" id="L346">        event.setOperationCode(operationCode);</span>
<span class="fc" id="L347">        event.setNewEntityType(newEntityType);</span>
<span class="fc" id="L348">        event.setOldEntityType(oldEntityType);</span>
<span class="fc" id="L349">        event.setEntityManagerName(this.getName());</span>
<span class="fc" id="L350">        this.notifyEvent(event);</span>
<span class="fc" id="L351">    }</span>

    /**
     * Return the map of the Entity Types managed by the service.
     *
     * @return The map of the Entity Types indexed by the type code.
     */
    protected Map&lt;String, IApsEntity&gt; getEntityTypes() {
<span class="fc" id="L359">        Map&lt;String, IApsEntity&gt; types = null;</span>
        try {
<span class="fc" id="L361">            types = this.getEntityTypeFactory().extractEntityTypes(this.getEntityClass(),</span>
<span class="fc" id="L362">                                                                   this.getConfigItemName(), this.getEntityTypeDom(), super.getName(), this.getEntityDom());</span>
<span class="nc" id="L363">        } catch (Exception e) {</span>
<span class="nc" id="L364">            logger.error(&quot;Error while extracting entity types&quot;, e);</span>
<span class="nc" id="L365">            throw new RuntimeException(&quot;Error while extracting entity types&quot;, e);</span>
<span class="fc" id="L366">        }</span>
<span class="fc" id="L367">        return types;</span>
    }

    @Override
    public Map&lt;String, AttributeInterface&gt; getEntityAttributePrototypes() {
<span class="fc" id="L372">        Collection&lt;AttributeInterface&gt; attributes = this.getEntityTypeDom().getAttributeTypes().values();</span>
<span class="fc" id="L373">        Map&lt;String, AttributeInterface&gt; attributeMap = new HashMap&lt;&gt;(attributes.size());</span>
<span class="fc" id="L374">        Iterator&lt;AttributeInterface&gt; iter = attributes.iterator();</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">        while (iter.hasNext()) {</span>
<span class="fc" id="L376">            AttributeInterface attributeInterface = iter.next();</span>
<span class="fc" id="L377">            AttributeInterface clone = (AttributeInterface) attributeInterface.getAttributePrototype();</span>
<span class="fc" id="L378">            attributeMap.put(clone.getType(), clone);</span>
<span class="fc" id="L379">        }</span>
<span class="fc" id="L380">        return attributeMap;</span>
    }

    protected IEntityTypeFactory getEntityTypeFactory() {
<span class="fc" id="L384">        return this.entityTypeFactory;</span>
    }

    /**
     * Set up the Entity Types factory. This method is used and hereby found in
     * the spring XML configuration of the service. By default, the definition
     * of the abstract service in the Spring configuration presents a standard
     * factory; such definition must be substituted in the declaration of the
     * service if specific operations are required by the particular structure
     * of the Entity Type to manage.
     *
     * @param entityTypeFactory The factory of Entity Types.
     */
    public void setEntityTypeFactory(IEntityTypeFactory entityTypeFactory) {
<span class="fc" id="L398">        this.entityTypeFactory = entityTypeFactory;</span>
<span class="fc" id="L399">    }</span>

    /**
     * This method is used and hereby found in the spring XML configuration of
     * the service. By default, the declaration of the abstract service in the
     * Spring configuration presents a standard class (ApsEntity); this class
     * must be substituted in the definition of the service if a different
     * class, which extends the standard ApsEntity, must be used. This method
     * checks the validity of the class.
     *
     * @param className The name of the entity class.
     */
    public void setEntityClassName(String className) {
        try {
<span class="fc" id="L413">            this.entityClass = Class.forName(className, true, Thread.currentThread().getContextClassLoader());</span>
<span class="fc" id="L414">            Class check = this.entityClass;</span>
            do {
<span class="fc" id="L416">                Class[] interfaces = check.getInterfaces();</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                for (int j = 0; j &lt; interfaces.length; j++) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                    if (interfaces[j].equals(IApsEntity.class)) {</span>
<span class="fc" id="L419">                        return;</span>
                    }
                }
<span class="fc" id="L422">                check = check.getSuperclass();</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            } while (!check.equals(Object.class));</span>
<span class="nc" id="L424">            throw new RuntimeException(&quot;Invalid entity class&quot;);</span>
<span class="nc" id="L425">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L426">            logger.error(&quot;Errore creating the entity class&quot;, e);</span>
<span class="nc" id="L427">            throw new RuntimeException(&quot;Error creating the entity class&quot;, e);</span>
        }
    }

    @Override
    public Class getEntityClass() {
<span class="fc" id="L433">        return this.entityClass;</span>
    }

    /**
     * Return The name of the configuration item where to extract the definition
     * of the Entity types.
     *
     * @return The name of the configuration item.
     */
    protected String getConfigItemName() {
<span class="fc" id="L443">        return this.configItemName;</span>
    }

    /**
     * Prepare the configuration item where to extract the definition of the
     * various Entity types managed by the service.
     *
     * @param confItemName The name of the configuration item where to extract
     * the definition of the Entity types
     */
    public void setConfigItemName(String confItemName) {
<span class="fc" id="L454">        this.configItemName = confItemName;</span>
<span class="fc" id="L455">    }</span>

    protected IEntityTypeDOM getEntityTypeDom() {
<span class="fc" id="L458">        return this.entityTypeDom;</span>
    }

    /**
     * Prepare the DOM class that interprets the XML defining the various Entity
     * Types managed by the service. This method is used and hereby found in the
     * Spring XML configuration of the service. By default, the declaration of
     * the abstract service contains the standard DOM class, namely the
     * EntityTypeDOM; this definition can be substituted in the declaration of
     * the service if a different DOM class, implementing the IEntityTypeDOM
     * interface, is used. This is, for example, to interpret customized Entity
     * Types -all implementing the ApsEntity- in a new service.
     *
     * @param entityTypeDom The DOM class that parses the XML configuring the
     * Entity Types.
     */
    public void setEntityTypeDom(IEntityTypeDOM entityTypeDom) {
<span class="fc" id="L475">        this.entityTypeDom = entityTypeDom;</span>
<span class="fc" id="L476">    }</span>

    /**
     * Set up the name of the root attribute in the XML representing the single
     * entity. This method is used and found in the Spring XML definition of the
     * service. By default, the definition of the abstract service in the Spring
     * configuration, presents the name &quot;entity&quot;; this definition can be
     * substituted in the implementation of the service if a new name is used.
     *
     * @param xmlAttributeRootElementName The name of the root attribute.
     */
    public void setXmlAttributeRootElementName(String xmlAttributeRootElementName) {
<span class="fc" id="L488">        this.xmlAttributeRootElementName = xmlAttributeRootElementName;</span>
<span class="fc" id="L489">    }</span>

    protected String getXmlAttributeRootElementName() {
<span class="fc" id="L492">        return this.xmlAttributeRootElementName;</span>
    }

    /**
     * Set up the handler class that parses the XML defining single entities.
     * This method is used and hereby found in the Spring XML configuration of
     * the service. The definition of the abstract service in the Spring
     * configuration presents a default handler class, namely the EntityHandler;
     * this definition can be changed in the declaration of the service if a
     * particular handler, which extends EntityHandler, is used to parse
     * specific entities. The class of such entities must extend the ApsEntity
     * class to be correctly managed by the service.
     *
     * @param entityHandler The handler class that parses the XML of the single
     * entities.
     */
    public void setEntityHandler(EntityHandler entityHandler) {
<span class="fc" id="L509">        this.entityHandler = entityHandler;</span>
<span class="fc" id="L510">    }</span>

    /**
     * Return the handler class that parses the single entity. This method
     * returns a prototype ready to be used to parse an entity.
     *
     * @return The handler class that parses the XML of the entity.
     */
    protected EntityHandler getEntityHandler() {
<span class="fc" id="L519">        return this.entityHandler.getHandlerPrototype();</span>
    }

    protected IApsEntityDOM getEntityDom() {
<span class="fc" id="L523">        return this.entityDom;</span>
    }

    /**
     * Set the DOM class that generates the XML that represents a single entity.
     * This method is used and hereby found in the Spring XML configuration of
     * the service. By default, the definition of the abstract service in the
     * Spring configuration, presents a standard DOM class, namely the
     * ApsEntityDOM; this definition can be substituted in the declaration of
     * the service if a different DOM class, implementing the IApsEntityDOM
     * interface, is used to generate the XML of particular entities. Such
     * entities are mapped to a class that must extend, as usual, the ApsEntity
     * class.
     *
     * @param entityDom the entity type dom
     */
    public void setEntityDom(IApsEntityDOM entityDom) {
<span class="fc" id="L540">        this.entityDom = entityDom;</span>
<span class="fc" id="L541">    }</span>

    /**
     * Search entities.
     *
     * @param filters The filters used to find an sort the entities ID that
     * match the given criteria.
     * @return The list of the IDs found.
     * @throws EntException In case of error.
     */
    @Override
    public List&lt;String&gt; searchId(EntitySearchFilter[] filters) throws EntException {
<span class="fc" id="L553">        List&lt;String&gt; idList = null;</span>
        try {
<span class="fc" id="L555">            idList = this.getEntitySearcherDao().searchId(filters);</span>
<span class="nc" id="L556">        } catch (Throwable t) {</span>
<span class="nc" id="L557">            logger.error(&quot;Error detected while searching entities&quot;, t);</span>
<span class="nc" id="L558">            throw new EntException(&quot;Error detected while searching entities&quot;, t);</span>
<span class="fc" id="L559">        }</span>
<span class="fc" id="L560">        return idList;</span>
    }

    /**
     * Search entities.
     *
     * @param typeCode The code of the Entity Types to look for.
     * @param filters The search filters to apply to find and sort the ID found.
     * @return The list of the ID found.
     * @throws EntException In case of error.
     */
    @Override
    public List&lt;String&gt; searchId(String typeCode, EntitySearchFilter[] filters) throws EntException {
<span class="fc" id="L573">        List&lt;String&gt; idList = null;</span>
        try {
<span class="fc" id="L575">            idList = this.getEntitySearcherDao().searchId(typeCode, filters);</span>
<span class="nc" id="L576">        } catch (Throwable t) {</span>
<span class="nc" id="L577">            logger.error(&quot;Error detected while searching entities with typeCode {}&quot;, typeCode, t);</span>
<span class="nc" id="L578">            throw new EntException(&quot;Error detected while searching entities&quot;, t);</span>
<span class="fc" id="L579">        }</span>
<span class="fc" id="L580">        return idList;</span>
    }

    @Override
    public List&lt;ApsEntityRecord&gt; searchRecords(EntitySearchFilter[] filters) throws EntException {
<span class="fc" id="L585">        List&lt;ApsEntityRecord&gt; records = null;</span>
        try {
<span class="fc" id="L587">            records = this.getEntitySearcherDao().searchRecords(filters);</span>
<span class="nc" id="L588">        } catch (Throwable t) {</span>
<span class="nc" id="L589">            logger.error(&quot;Error searching entity records&quot;, t);</span>
<span class="nc" id="L590">            throw new EntException(&quot;Error searching entity records&quot;, t);</span>
<span class="fc" id="L591">        }</span>
<span class="fc" id="L592">        return records;</span>
    }

    @Override
    public void reloadEntitiesReferences(ReloadingEntitiesReferencesEvent event) {
        try {
<span class="nc" id="L598">            String typeCode = null;</span>
<span class="nc" id="L599">            this.reloadEntitiesReferences(typeCode);</span>
<span class="nc" id="L600">        } catch (Throwable t) {</span>
<span class="nc" id="L601">            logger.error(&quot;Error while refreshing entity refrences&quot;, t);</span>
<span class="nc" id="L602">        }</span>
<span class="nc" id="L603">    }</span>

    @Override
    public Thread reloadEntitiesReferences(String typeCode) {
<span class="fc" id="L607">        ReloadingReferencesThread reloadThread = null;</span>
<span class="pc bpc" id="L608" title="1 of 4 branches missed.">        if (this.getStatus() == STATUS_READY || this.getStatus(typeCode) != STATUS_RELOADING_REFERENCES_IN_PROGRESS) {</span>
            try {
<span class="fc" id="L610">                reloadThread = new ReloadingReferencesThread(this, typeCode);</span>
<span class="fc" id="L611">                String threadName = RELOAD_REFERENCES_THREAD_NAME_PREFIX + this.getName() + &quot;_&quot; + DateConverter.getFormattedDate(new Date(), &quot;yyyyMMddHHmmss&quot;);</span>
<span class="fc" id="L612">                reloadThread.setName(threadName);</span>
<span class="fc" id="L613">                reloadThread.start();</span>
<span class="fc" id="L614">                logger.info(&quot;Reloading references started&quot;);</span>
<span class="nc" id="L615">            } catch (Throwable t) {</span>
<span class="nc" id="L616">                logger.error(&quot;Error while starting up the reference reload procedure&quot;, t);</span>
<span class="nc" id="L617">                throw new RuntimeException(&quot;Error while starting up the reference reload procedure&quot;, t);</span>
<span class="fc" id="L618">            }</span>
        } else {
<span class="nc" id="L620">            logger.info(&quot;Reloading entity references suspended: status {}&quot;, this.getStatus(typeCode));</span>
        }
<span class="fc" id="L622">        return reloadThread;</span>
    }

    /**
     * Reload the entity references.
     *
     * @param typeCode The type Code of entities to reload references. If null,
     * will reload all entities.
     * @throws EntException In case of error.
     */
    protected synchronized void reloadEntitySearchReferencesByType(String typeCode) throws EntException {
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        if (null == typeCode) {</span>
<span class="nc" id="L634">            throw new EntException(&quot;Error: invalid type code detected&quot;);</span>
        }
<span class="fc" id="L636">        this.setStatus(ApsEntityManager.STATUS_RELOADING_REFERENCES_IN_PROGRESS, typeCode);</span>
        try {
<span class="fc" id="L638">            EntitySearchFilter filter = new EntitySearchFilter(ENTITY_TYPE_CODE_FILTER_KEY, false, typeCode, false);</span>
<span class="fc" id="L639">            EntitySearchFilter[] filters = {filter};</span>
<span class="fc" id="L640">            List&lt;String&gt; entitiesId = this.getEntitySearcherDao().searchId(filters);</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">            for (int i = 0; i &lt; entitiesId.size(); i++) {</span>
<span class="fc" id="L642">                String entityId = (String) entitiesId.get(i);</span>
<span class="fc" id="L643">                this.reloadEntityReferences(entityId);</span>
            }
<span class="nc" id="L645">        } catch (Throwable t) {</span>
<span class="nc" id="L646">            logger.error(&quot;Error reloading entity references of type: {}&quot;, typeCode, t);</span>
<span class="nc" id="L647">            throw new EntException(&quot;Error reloading entity references of type: &quot; + typeCode, t);</span>
        } finally {
<span class="fc" id="L649">            this.setStatus(ApsEntityManager.STATUS_READY, typeCode);</span>
        }
<span class="fc" id="L651">    }</span>

    protected void reloadEntityReferences(String entityId) {
        try {
<span class="fc" id="L655">            IApsEntity entity = this.getEntity(entityId);</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">            if (entity != null) {</span>
<span class="fc" id="L657">                this.getEntityDao().reloadEntitySearchRecords(entityId, entity);</span>
            }
<span class="fc" id="L659">            logger.info(&quot;Entities search references reloaded {}&quot;, entityId);</span>
<span class="nc" id="L660">        } catch (Throwable t) {</span>
<span class="nc" id="L661">            logger.error(&quot;Error reloading the entities search references: {}&quot;, entityId, t);</span>
<span class="fc" id="L662">        }</span>
<span class="fc" id="L663">    }</span>

    /**
     * Load the complete list of the entities.
     *
     * @return The complete list of entity IDs.
     * @throws EntException In case of error.
     * @deprecated From jAPS 2.0 version 2.0.9, use {@link IEntitySearcherDAO}
     * searchId(EntitySearchFilter[]) method
     */
    protected List&lt;String&gt; getAllEntityId() throws EntException {
<span class="nc" id="L674">        List&lt;String&gt; entitiesId = new ArrayList&lt;&gt;();</span>
        try {
<span class="nc" id="L676">            entitiesId = this.getEntityDao().getAllEntityId();</span>
<span class="nc" id="L677">        } catch (Throwable t) {</span>
<span class="nc" id="L678">            logger.error(&quot;Error while loading the complete list of entity IDs&quot;, t);</span>
<span class="nc" id="L679">            throw new EntException(&quot;Error while loading the complete list of entity IDs&quot;, t);</span>
<span class="nc" id="L680">        }</span>
<span class="nc" id="L681">        return entitiesId;</span>
    }

    @Override
    public List&lt;SmallEntityType&gt; getSmallEntityTypes() {
<span class="fc" id="L686">        List&lt;SmallEntityType&gt; smallTypes = null;</span>
        try {
<span class="fc" id="L688">            smallTypes = this.getEntityTypeFactory().extractSmallEntityTypes(this.getConfigItemName(), this.getEntityTypeDom());</span>
<span class="fc" id="L689">            BeanComparator comparator = new BeanComparator(&quot;description&quot;);</span>
<span class="fc" id="L690">            Collections.sort(smallTypes, comparator);</span>
<span class="nc" id="L691">        } catch (Exception e) {</span>
<span class="nc" id="L692">            logger.error(&quot;Error while extracting small entity types&quot;, e);</span>
<span class="nc" id="L693">            throw new RuntimeException(&quot;Error while extracting small entity types&quot;, e);</span>
<span class="fc" id="L694">        }</span>
<span class="fc" id="L695">        return smallTypes;</span>
    }

    /**
     * Return the stutus of the desired entity. If nell it returns the general
     * status.
     *
     * @param typeCode The Entity type to get the status from. It may be null.
     * @return The status of the desidered entity.
     */
    @Override
    public int getStatus(String typeCode) {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (typeCode == null) {</span>
<span class="nc" id="L708">            return this.getStatus();</span>
        }
<span class="fc" id="L710">        return this.getCacheWrapper().getEntityTypeStatus(typeCode);</span>
    }

    @Override
    public int getStatus() {
<span class="fc" id="L715">        Set&lt;Integer&gt; status = new HashSet&lt;&gt;();</span>
<span class="fc" id="L716">        List&lt;String&gt; codes = this.getEntityTypeCodes();</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">        for (String code : codes) {</span>
<span class="fc" id="L718">            status.add(this.getCacheWrapper().getEntityTypeStatus(code));</span>
<span class="fc" id="L719">        }</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">        if (status.contains(STATUS_RELOADING_REFERENCES_IN_PROGRESS)) {</span>
<span class="fc" id="L721">            return STATUS_RELOADING_REFERENCES_IN_PROGRESS;</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        } else if (status.contains(STATUS_NEED_TO_RELOAD_REFERENCES)) {</span>
<span class="nc" id="L723">            return STATUS_NEED_TO_RELOAD_REFERENCES;</span>
        }
<span class="fc" id="L725">        return STATUS_READY;</span>
    }

    protected String getAttributeRolesFileName() {
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">        if (null == this.attributeRolesFileName) {</span>
<span class="fc" id="L730">            return DEFAULT_ATTRIBUTE_ROLES_FILE_NAME;</span>
        }
<span class="nc" id="L732">        return attributeRolesFileName;</span>
    }

    public void setAttributeRolesFileName(String attributeRolesFileName) {
<span class="nc" id="L736">        this.attributeRolesFileName = attributeRolesFileName;</span>
<span class="nc" id="L737">    }</span>

    protected String getAttributeDisablingCodesFileName() {
<span class="pc bpc" id="L740" title="1 of 2 branches missed.">        if (null == this.attributeDisablingCodesFileName) {</span>
<span class="fc" id="L741">            return DEFAULT_ATTRIBUTE_DISABLING_CODES_FILE_NAME;</span>
        }
<span class="nc" id="L743">        return attributeDisablingCodesFileName;</span>
    }

    public void setAttributeDisablingCodesFileName(String disablingCodesFileName) {
<span class="nc" id="L747">        this.attributeDisablingCodesFileName = disablingCodesFileName;</span>
<span class="nc" id="L748">    }</span>

    /**
     * Imposta lo stato del tipo di entità dato. Se null imposta lo stato
     * generale. Set up the status of the given entity. If null it sets up the
     * overall status.
     *
     * @param status The status to set up.
     * @param typeCode The Entity Type where to apply the new status. If null it
     * sets up the general status.
     */
    protected void setStatus(int status, String typeCode) {
<span class="fc" id="L760">        this.getCacheWrapper().updateEntityTypeStatus(typeCode, status);</span>
<span class="fc" id="L761">    }</span>

    protected List&lt;String&gt; getEntityTypeCodes() {
<span class="fc" id="L764">        List&lt;String&gt; codes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L765">        List&lt;SmallEntityType&gt; smallTypes = this.getSmallEntityTypes();</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">        for (SmallEntityType smallType : smallTypes) {</span>
<span class="fc" id="L767">            codes.add(smallType.getCode());</span>
<span class="fc" id="L768">        }</span>
<span class="fc" id="L769">        return codes;</span>
    }

    /**
     * Return the DAO to access the entity database with.
     *
     * @return The entity DAO.
     */
    protected abstract IEntityDAO getEntityDao();

    /**
     * Return the DAO used to search among entities.
     *
     * @return TheDAO used to search entities.
     */
    protected abstract IEntitySearcherDAO getEntitySearcherDao();

    protected IEntityManagerCacheWrapper getCacheWrapper() {
<span class="fc" id="L787">        return cacheWrapper;</span>
    }

    public void setCacheWrapper(IEntityManagerCacheWrapper cacheWrapper) {
<span class="fc" id="L791">        this.cacheWrapper = cacheWrapper;</span>
<span class="fc" id="L792">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>